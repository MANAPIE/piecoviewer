import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { userQueries, settingsQueries, reviewQueries } from '@/lib/db/sqlite';
import { getAIProvider } from '@/lib/ai';

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession();

    if (!session?.user?.email) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const user = userQueries.findByEmail(session.user.email);

    if (!user) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    const settings = settingsQueries.findByUserId(user.id);

    if (!settings) {
      return NextResponse.json(
        { error: 'User settings not found' },
        { status: 404 }
      );
    }

    const body = await request.json();
    const { owner, repo, prNumber, pullRequest, files } = body as {
      owner: string;
      repo: string;
      prNumber: number;
      pullRequest: { title: string; body: string | null };
      files: Array<{
        filename: string;
        status: string;
        additions: number;
        deletions: number;
        patch?: string;
      }>;
    };

    // AI Provider ÏÑ§Ï†ï
    const aiProvider = getAIProvider(settings.ai_provider);

    // API ÌÇ§ ÏÑ§Ï†ï
    const apiKey =
      settings.ai_provider === 'claude'
        ? settings.claude_api_key
        : settings.ai_provider === 'openai'
        ? settings.openai_api_key
        : settings.gemini_api_key;

    if (!apiKey) {
      return NextResponse.json(
        { error: 'API key not configured' },
        { status: 400 }
      );
    }

    aiProvider.setApiKey(apiKey);

    // Diff ÏÉùÏÑ±
    const diff = files
      .map((file) => {
        return `--- a/${file.filename}
+++ b/${file.filename}
${file.patch || ''}`;
      })
      .join('\n\n');

    // AI Î¶¨Î∑∞ ÏÉùÏÑ±
    const result = await aiProvider.review(diff, {
      prTitle: pullRequest.title,
      prDescription: pullRequest.body || '',
      fileChanges: files.map((f) => ({
        filename: f.filename,
        status: f.status as 'added' | 'modified' | 'removed',
        additions: f.additions,
        deletions: f.deletions,
        patch: f.patch
      })),
      customPrompt: settings.custom_prompt || undefined
    });

    // PIEcoviewer Ìë∏ÌÑ∞ Ï∂îÍ∞Ä
    const piecoviewerUrl = process.env.PIECOVIEWER_URL || 'https://github.com/yourusername/piecoviewer';
    const reviewWithFooter = `${result.summary}\n\n---\n*ü§ñ Generated by [PIEcoviewer](${piecoviewerUrl})*`;

    // Î¶¨Î∑∞ Í≤∞Í≥ºÎ•º DBÏóê Ï†ÄÏû•
    const review = reviewQueries.create({
      userId: user.id,
      repoOwner: owner,
      repoName: repo,
      prNumber,
      reviewContent: reviewWithFooter,
      fileComments: JSON.stringify(result.fileComments),
      aiProvider: settings.ai_provider
    });

    return NextResponse.json({
      success: true,
      review: reviewWithFooter,
      reviewId: review.id,
      fileComments: result.fileComments
    });
  } catch (error) {
    console.error('AI review error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Failed to generate review';
    return NextResponse.json(
      { error: errorMessage },
      { status: 500 }
    );
  }
}