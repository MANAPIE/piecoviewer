import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { prisma } from '@/lib/db/prisma';
import { getAIProvider } from '@/lib/ai';

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession();

    if (!session?.user?.email) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const user = await prisma.user.findFirst({
      where: { email: session.user.email },
      include: { settings: true }
    });

    if (!user || !user.settings) {
      return NextResponse.json(
        { error: 'User settings not found' },
        { status: 404 }
      );
    }

    const body = await request.json();
    const { owner, repo, prNumber, pullRequest, files } = body as {
      owner: string;
      repo: string;
      prNumber: number;
      pullRequest: { title: string; body: string | null };
      files: Array<{
        filename: string;
        status: string;
        additions: number;
        deletions: number;
        patch?: string;
      }>;
    };

    // AI Provider ÏÑ§Ï†ï
    const aiProvider = getAIProvider(user.settings.aiProvider);

    // API ÌÇ§ ÏÑ§Ï†ï
    const apiKey =
      user.settings.aiProvider === 'claude'
        ? user.settings.claudeApiKey
        : user.settings.aiProvider === 'openai'
        ? user.settings.openaiApiKey
        : user.settings.geminiApiKey;

    if (!apiKey) {
      return NextResponse.json(
        { error: 'API key not configured' },
        { status: 400 }
      );
    }

    aiProvider.setApiKey(apiKey);

    // Diff ÏÉùÏÑ±
    const diff = files
      .map((file) => {
        return `--- a/${file.filename}
+++ b/${file.filename}
${file.patch || ''}`;
      })
      .join('\n\n');

    // AI Î¶¨Î∑∞ ÏÉùÏÑ±
    const result = await aiProvider.review(diff, {
      prTitle: pullRequest.title,
      prDescription: pullRequest.body || '',
      fileChanges: files.map((f) => ({
        filename: f.filename,
        status: f.status as 'added' | 'modified' | 'removed',
        additions: f.additions,
        deletions: f.deletions,
        patch: f.patch
      })),
      customPrompt: user.settings.customPrompt || undefined
    });

    // PIEcoviewer Ìë∏ÌÑ∞ Ï∂îÍ∞Ä
    const piecoviewerUrl = process.env.PIECOVIEWER_URL || 'https://github.com/yourusername/piecoviewer';
    const reviewWithFooter = `${result.summary}\n\n---\n*ü§ñ Generated by [PIEcoviewer](${piecoviewerUrl})*`;

    // Î¶¨Î∑∞ Í≤∞Í≥ºÎ•º DBÏóê Ï†ÄÏû•
    const review = await prisma.review.create({
      data: {
        userId: user.id,
        repoOwner: owner,
        repoName: repo,
        prNumber,
        prTitle: pullRequest.title,
        aiProvider: user.settings.aiProvider,
        reviewContent: reviewWithFooter,
        fileComments: JSON.stringify(result.fileComments),
        isPosted: false
      }
    });

    return NextResponse.json({
      success: true,
      review: reviewWithFooter,
      reviewId: review.id,
      fileComments: result.fileComments
    });
  } catch (error) {
    console.error('AI review error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Failed to generate review';
    return NextResponse.json(
      { error: errorMessage },
      { status: 500 }
    );
  }
}